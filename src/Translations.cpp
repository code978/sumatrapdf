/* Copyright 2013 the SumatraPDF project authors (see AUTHORS file).
   License: BSD */

#include "BaseUtil.h"
#include "Translations.h"

/*
TODO:
 - special-case english strings. Store them as before in const char * gEnglishStrings[STRINGS_COUNT] = { ... }
   array. That way the compiler should be able to de-duplicate those strings with strings that are in the
   source code inside _TR() macor
 - compress the translations and de-compress them on demand
*/

namespace trans {

// This code relies on data defined in Translations_txt.cpp, which is
// generated by scripts\trans_gen.py

#include "Translations_txt.cpp"

#define INVALID_OFFSET 0xFFFF

static LangDef *gDefaultLang = &gLanguages[0];
static LangDef *gCurrLang = NULL;

/* In general, after adding new _TR() strings, one has to re-generate Translations_txt.cpp, but
that also requires uploading new strings to the server, for which one needs accesss.

To support adding new strings without re-generating Translatiosn_txt.cpp, we have a concept
of missing translations. */

struct MissingTranslation {
    const char *s;
    const WCHAR *translation;
};

// number of missing translations should be small
static MissingTranslation gMissingTranslations[64];
static int gMissingTranslationsCount = 0;

static void FreeMissingTranslations()
{
    for (int i=0; i < gMissingTranslationsCount; i++) {
        free((void*)gMissingTranslations[i].translation);
    }
    gMissingTranslationsCount = 0;
}

static const WCHAR *FindOrAddMissingTranslation(const char *s)
{
    for (int i = 0; i < gMissingTranslationsCount; i++) {
        if (s == gMissingTranslations[i].s) {
            return gMissingTranslations[i].translation;
        }
    }
    if (gMissingTranslationsCount >= dimof(gMissingTranslations))
        return L"missing translation";

    gMissingTranslations[gMissingTranslationsCount].s = s;
    const WCHAR *res = str::conv::FromUtf8(s);
    gMissingTranslations[gMissingTranslationsCount].translation = res;
    gMissingTranslationsCount++;
    return res;
}

static void CalcOffsets(LangDef *lang)
{
    if (lang->translationsOffsets)
        return;
    const char *s = lang->translations;
    uint16_t *offsets = AllocArray<uint16_t>(STRINGS_COUNT);
    uint16_t curr = 0;
    for (int i = 0; i < STRINGS_COUNT; i++) {
        size_t len = str::Len(s);
        if (0 == len)
            offsets[i] = INVALID_OFFSET;
        else
            offsets[i] = curr;
        curr = curr + len + 1;
        s = s + len + 1;
    }
    CrashAlwaysIf(curr > 65535); // time to change translationsOffsets to use uint32_t
    lang->translationsOffsets = offsets;
}

void SetCurrentLang(LangDef *lang)
{
    if (gCurrLang == lang)
        return;

    FreeMissingTranslations();
    gCurrLang = lang;
    CalcOffsets(gCurrLang);
}

LangDef *GetCurrentLang()
{
    return gCurrLang;
}

int GetLangsCount()
{
    return LANGS_COUNT;
}

LangDef *GetLang(int i)
{
    CrashIf(i >= LANGS_COUNT);
    return &gLanguages[i];
}

LangDef *GuessLang()
{
    LANGID langId = GetUserDefaultUILanguage();
    LANGID langIdNoSublang = MAKELANGID(PRIMARYLANGID(langId), SUBLANG_NEUTRAL);

    // Either find the exact primary/sub lang id match, or a neutral sublang if it exists
    // (don't return any sublang for a given language, it might be too different)
    LangDef *langDef = gDefaultLang;
    for (int i = 0; i < LANGS_COUNT; i++) {
        if (langId == gLanguages[i].langId)
            return &gLanguages[i];

        if (langIdNoSublang == gLanguages[i].langId) {
            langDef = &gLanguages[i];
            // continue searching after finding a match with a neutral sublanguage
        }
    }

    return langDef;
}

LangDef *GetLangByCode(const char *code)
{
    for (int i = 0; i < LANGS_COUNT; i++) {
        if (str::Eq(code, gLanguages[i].code))
            return &gLanguages[i];
    }
    return NULL;
}

static int cmpCharPtrs(const void *a, const void *b)
{
    return strcmp(*(const char **)a, *(const char **)b);
}

// find the index of this string in the english (i.e. untranslated) strings
// Note: could be sped up with binary search but seems to be fast enough even now
static int GetEnglishStringIndex(const char* txt)
{
    LangDef *lang = gDefaultLang;
    if (!lang->translationsOffsets)
        CalcOffsets(lang);

    const char *s = lang->translations;
    int res;
    for (int i = 0; i < STRINGS_COUNT; i++) {
        res = strcmp(txt, s);
        if (0 == res)
            return i;
        s = s + str::Len(s) + 1;
    }
    CrashIf(1);
    return -1;

#if 0
    uint16_t * offsets = gLanguages[0].translationsOffsets;
    const char * translations = gLanguages[0].translations;
    const char **res = (const char **)bsearch(&txt, offsets, STRINGS_COUNT, sizeof(txt), cmpCharPtrs);
    if (!res) {
        // didn't find a translation
        return -1;
    }

    return (int)(res - translations);
    return -1;
#endif
}

// Call at program exit to free all memory related to translations functionality.
void Destroy()
{
    for (int i = 0; i < dimof(gLanguages); i++) {
        free(gLanguages[i].translationsOffsets);
        gLanguages[i].translationsOffsets = NULL;
        const WCHAR **cache = gLanguages[i].translationsCache;
        if (!cache)
            continue;
        for (int n = 0; n < STRINGS_COUNT; n++) {
            free((void*)cache[n]);
        }
        free(cache);
        gLanguages[i].translationsCache = NULL;
    }
    FreeMissingTranslations();
}

// Return a properly encoded version of a translation for 'txt'.
// Memory for the string needs to be allocated and is cached in LangDef.translationCache
// array. That way the client doesn't have to worry about the lifetime of the string.
// All allocated strings can be freed with Trans::Destroy()
const WCHAR *GetTranslation(const char *txt)
{
    int idx = GetEnglishStringIndex(txt);
    if (-1 == idx)
        return FindOrAddMissingTranslation(txt);

    LangDef *lang = gCurrLang;
    uint16_t offset = (int)lang->translationsOffsets[idx];
    // fall back to English if the language doesn't have a translations for this string
    if (INVALID_OFFSET == offset) {
        lang = gDefaultLang;
        offset = lang->translationsOffsets[idx];
        CrashIf(INVALID_OFFSET == offset);
    }

    const char *trans = lang->translations + offset;
    const WCHAR **cache = lang->translationsCache;
    if (!cache) {
        lang->translationsCache = AllocArray<const WCHAR *>(STRINGS_COUNT);
        if (!lang->translationsCache)
            return L"missing translation";
        cache = lang->translationsCache;
    }

    if (!cache[idx])
        cache[idx] = str::conv::FromUtf8(trans);
    return cache[idx];
}

}
