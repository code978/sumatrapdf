/* Copyright 2006-2011 the SumatraPDF project authors (see AUTHORS file).
   License: GPLv3 */

#include "BaseUtil.h"
#include "translations.h"
#include "StrUtil.h"

namespace Trans {

/*
This code relies on the following variables that must be defined in 
the separate file translations_txt.cpp
The idea is that this file is automatically generated 
by a script from translation files.

// array of language names so that g_transLangs[i] is a name of
// language. i is in 0 .. LANGS_COUNT-1
const char *g_transLangs[LANGS_COUNT];

// array of UTF-8 encoded translated strings. 
// it has LANGS_COUNT * STRINGS_COUNT elements
// (for simplicity). Translation i for language n is at position
// (n * STRINGS_COUNT) + i
const char *g_transTranslations[LANGS_COUNT * STRINGS_COUNT];

// array of language codes, names and IDs
// used for determining the human readable name of a language
// and for guessing the OS's current language settings
LangDef g_langs[LANGS_COUNT];
*/

#include "translations_txt.cpp"

// numeric index of the current language. 0 ... LANGS_COUNT-1
static int g_currLangIdx = 0;
static const TCHAR **g_translations = NULL;  // cached translations

const char *GuessLanguage()
{
    LANGID langId = GetUserDefaultUILanguage();
    LANGID langIdNoSublang = MAKELANGID(PRIMARYLANGID(langId), SUBLANG_NEUTRAL);
    const char *langName = NULL;

    // Either find the exact primary/sub lang id match, or a neutral sublang if it exists
    // (don't return any sublang for a given language, it might be too different)
    for (int i = 0; i < LANGS_COUNT; i++) {
        if (langId == g_langs[i]._langId)
            return g_langs[i]._langName;

        if (langIdNoSublang == g_langs[i]._langId)
            langName = g_langs[i]._langName;
        // continue searching after finding a match with a neutral sublanguage
    }

    return langName;
}

bool SetCurrentLanguage(const char *lang)
{
    for (size_t i = 0; i < dimof(g_transLangs); i++) {
        if (Str::Eq(lang, g_transLangs[i])) {
            g_currLangIdx = i;
            return true;
        }
    }
    return false;
}

static int cmpCharPtrs(const void *a, const void *b)
{
    return strcmp(*(char **)a, *(char **)b);
}

static int GetTranslationIndex(const char* txt)
{
    assert(g_currLangIdx < LANGS_COUNT);
    const char **res = (const char **)bsearch(&txt, &g_transTranslations, STRINGS_COUNT, sizeof(g_transTranslations[0]), cmpCharPtrs);
    assert(res);
    if (!res) {
        // bad - didn't find a translation
        return -1;
    }

    return (int)(res - g_transTranslations);
}

// Call at program exit to free all memory related to translations functionality.
static int FreeData()
{
    if (!g_translations)
        return 0;
    for (size_t i = 0; i < dimof(g_transTranslations); i++)
        free((void *)g_translations[i]);
    free((void *)g_translations);
    g_translations = NULL;
    return 0;
}

// Return a properly encoded version of a translation for 'txt'.
// Memory for the string needs to be allocated and is cached in g_translations
// array. That way the client doesn't have to worry about the lifetime of the string.
// All allocated strings can be freed with Trans::FreeData(), which should be
// done at program exit so that we're guaranteed no-one is using the data
const TCHAR *GetTranslation(const char *txt)
{
    if (!g_translations) {
        assert(dimof(g_transTranslations) == STRINGS_COUNT * LANGS_COUNT);
        g_translations = SAZA(const TCHAR *, dimof(g_transTranslations));
        if (!g_translations)
            return _T("Missing translation!?");
        _onexit(FreeData);
    }

    int idx = GetTranslationIndex(txt);
    assert(0 <= idx && idx < STRINGS_COUNT);
    if (-1 == idx)
        return _T("Missing translation!?");

    int transIdx = (g_currLangIdx * STRINGS_COUNT) + idx;
    // fall back to the English string, if a translation is missing
    if (!g_transTranslations[transIdx])
        transIdx = idx;

    if (!g_translations[transIdx])
        g_translations[transIdx] = Str::Conv::FromUtf8(g_transTranslations[transIdx]);
    return g_translations[transIdx];
}

// returns an arbitrary index for a given language code
// which can be used for calling GetLanguageCode and
// GetLanguageName (this index isn't guaranteed to remain
// stable after a restart, use the language code when saving
// the current language settings instead)
int GetLanguageIndex(const char *name)
{
    if (!name)
        return -1;

    for (int i = 0; i < LANGS_COUNT; i++) {
        const char *langName = g_langs[i]._langName;
        if (Str::Eq(name, langName))
            return i;
    }
    return -1;
}

const char *GetLanguageCode(int index)
{
    assert(index >= 0);
    if (index < 0)
        return NULL;

    if (LANGS_COUNT <= index)
        return NULL;
    return g_langs[index]._langName;
}

TCHAR *GetLanguageName(int index)
{
    assert(index >= 0);
    if (index < 0)
        return NULL;

    if (LANGS_COUNT <= index)
        return NULL;
    return Str::Conv::FromUtf8(g_langs[index]._langMenuTitle);
}

}
