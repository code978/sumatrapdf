// DON'T EDIT MANUALLY !!!!
// auto-generated by scripts/gen_settings.py !!!!

#include "BaseUtil.h"
#include "Settings.h"

#define MAGIC_ID 0x53756d53  // 'SumS' as 'Sumatra Settings'

#define SERIALIZED_HEADER_LEN 12

typedef struct {
    uint32_t   magicId;
    uint32_t   version;
    uint32_t   topLevelStructOffset;
} SerializedHeader;

STATIC_ASSERT(sizeof(SerializedHeader) == SERIALIZED_HEADER_LEN, SerializedHeader_is_12_bytes);

static const uint16_t TYPE_BOOL         = 0;
static const uint16_t TYPE_I16          = 1;
static const uint16_t TYPE_U16          = 2;
static const uint16_t TYPE_I32          = 3;
static const uint16_t TYPE_U32          = 4;
static const uint16_t TYPE_STR          = 5;
static const uint16_t TYPE_STRUCT_PTR   = 6;

struct FieldMetadata;

typedef struct {
    uint16_t        size;
    uint16_t        nFields;
    FieldMetadata * fields;
} StructMetadata;

// information about a single field
struct FieldMetadata {
    uint16_t type; // TYPE_*
    // from the beginning of the struct
    uint16_t offset;
    // type is TYPE_STRUCT_PTR, otherwise NULL
    StructMetadata *def;
};

FieldMetadata gForwardSearchSettingsFieldMetadata[] = {
    { TYPE_I32, offsetof(ForwardSearchSettings, highlightOffset), NULL },
    { TYPE_I32, offsetof(ForwardSearchSettings, highlightWidth), NULL },
    { TYPE_I32, offsetof(ForwardSearchSettings, highlightPermanent), NULL },
    { TYPE_U32, offsetof(ForwardSearchSettings, highlightColor), NULL },
};

StructMetadata gForwardSearchSettingsMetadata = { sizeof(ForwardSearchSettings), 4, &gForwardSearchSettingsFieldMetadata[0] };

FieldMetadata gPaddingSettingsFieldMetadata[] = {
    { TYPE_U16, offsetof(PaddingSettings, top), NULL },
    { TYPE_U16, offsetof(PaddingSettings, bottom), NULL },
    { TYPE_U16, offsetof(PaddingSettings, left), NULL },
    { TYPE_U16, offsetof(PaddingSettings, right), NULL },
    { TYPE_U16, offsetof(PaddingSettings, spaceX), NULL },
    { TYPE_U16, offsetof(PaddingSettings, spaceY), NULL },
};

StructMetadata gPaddingSettingsMetadata = { sizeof(PaddingSettings), 6, &gPaddingSettingsFieldMetadata[0] };

FieldMetadata gAdvancedSettingsFieldMetadata[] = {
    { TYPE_BOOL, offsetof(AdvancedSettings, traditionalEbookUI), NULL },
    { TYPE_BOOL, offsetof(AdvancedSettings, escToExit), NULL },
    { TYPE_STR, offsetof(AdvancedSettings, emptyString), NULL },
    { TYPE_U32, offsetof(AdvancedSettings, logoColor), NULL },
    { TYPE_STRUCT_PTR, offsetof(AdvancedSettings, pagePadding), &gPaddingSettingsMetadata },
    { TYPE_STRUCT_PTR, offsetof(AdvancedSettings, foo2Padding), &gPaddingSettingsMetadata },
    { TYPE_STR, offsetof(AdvancedSettings, notEmptyString), NULL },
    { TYPE_STRUCT_PTR, offsetof(AdvancedSettings, forwardSearch), &gForwardSearchSettingsMetadata },
};

StructMetadata gAdvancedSettingsMetadata = { sizeof(AdvancedSettings), 8, &gAdvancedSettingsFieldMetadata[0] };

static const uint8_t gAdvancedSettingsDefault[] = {
    0x53, 0x6d, 0x75, 0x53, // magic id 'SumS'
    0x00, 0x00, 0x03, 0x02, // version 2.3
    0x19, 0x00, 0x00, 0x00, // top-level struct offset 0x19

    // offset: 0xc StructVal@0xffde21ac ForwardSearchSettings
    0x00, // int32_t highlightOffset = 0x0
    0x0f, // int32_t highlightWidth = 0xf
    0x00, // int32_t highlightPermanent = 0x0
    0xff, 0x83, 0x96, 0x03, // uint32_t highlightColor = 0x6581ff

    // offset: 0x13 StructVal@0xffde206c PaddingSettings
    0x02, // uint16_t top = 0x2
    0x02, // uint16_t bottom = 0x2
    0x04, // uint16_t left = 0x4
    0x04, // uint16_t right = 0x4
    0x04, // uint16_t spaceX = 0x4
    0x04, // uint16_t spaceY = 0x4

    // offset: 0x19 StructVal@0xffde224c AdvancedSettings
    0x00, // bool traditionalEbookUI = 0x0
    0x00, // bool escToExit = 0x0
    0x00, // const char * emptyString = ""
    0x80, 0xe4, 0xff, 0x07, // uint32_t logoColor = 0xfff200
    0x13, // PaddingSettings * pagePadding = StructVal@0xffde206c
    0x00, // PaddingSettings * foo2Padding = NULL
    0x05, 0x48, 0x65, 0x6c, 0x6c, 0x6f, // const char * notEmptyString = "Hello"
    0x0c, // ForwardSearchSettings * forwardSearch = StructVal@0xffde21ac
};

// returns -1 on error
static int NextIntVal(const char **sInOut)
{
    const char *s = *sInOut;
    char c;
    int val = 0;
    int n;
    for (;;) {
        c = *s++;
        if (0 == c) {
            s--; // position at ending 0
            goto Exit;
        }
        if ('.' == c)
            goto Exit;
        n = c - '0';
        if ((c < 0) || (c > 9))
            return -1;
        val *= 10;
        val += n;
    }
Exit:
    if (val > 255)
        return -1;
    *sInOut = s;
    return val;
}

// parses a vrsion string in the format "x.y.z", of up to 4 parts
// return 0 on parsing error
static uint32_t VersionFromStr(const char *s)
{
    uint32_t ver = 0;
    int left = 4;
    int n;
    while (left > 0) {
        if (0 == *s)
            goto Exit;
        n = NextIntVal(&s);
        if (-1 == n)
            return 0;
        --left;
    }
Exit:
    ver = ver << (left * 8);
    return ver;
}

// the assumption here is that the data was either build by Deserialize()
// or was set by application code in a way that observes our rule: each
// object was separately allocated with malloc()
static void FreeStruct(uint8_t *data, StructMetadata *def)
{
    if (!data)
        return;
    FieldMetadata *fieldDef = NULL;
    for (int i = 0; i < def->nFields; i++) {
        fieldDef = def->fields + i;
        if (TYPE_STRUCT_PTR ==  fieldDef->type) {
            uint8_t **p = (uint8_t**)(data + fieldDef->offset);
            FreeStruct(*p, fieldDef->def);
        } else if (TYPE_STR == fieldDef->type) {
            char **s = (char**)(data + fieldDef->offset);
            free(*s);
        }
    }
    free(data);
}

static bool WriteStructVal(uint16_t type, uint64_t val, uint8_t *p)
{
    if (TYPE_BOOL == type) {
        if (val > 1)
            return false;
        bool b = (bool)val;
        bool *bp = (bool*)p;
        *bp = b;
        return true;
    } else if (TYPE_I16 == type) {
        if (val > 0xffff)
            return false;
        int16_t v = (int16_t)val;
        int16_t *vp = (int16_t*)p;
        *vp = v;
        return true;
    } else if (TYPE_U16 == type) {
        if (val > 0xffff)
            return false;
        uint16_t v = (uint16_t)val;
        uint16_t *vp = (uint16_t*)p;
        *vp = v;
        return true;
    } else if (TYPE_I32 == type) {
        if (val > 0xffffffff)
            return false;
        int32_t v = (int32_t)val;
        int32_t *vp = (int32_t*)p;
        *vp = v;
        return true;
    } else if (TYPE_U32 == type) {
        if (val > 0xffffffff)
            return false;
        uint32_t v = (uint32_t)val;
        uint32_t *vp = (uint32_t*)p;
        *vp = v;
        return true;
    }
    CrashIf(false);
    return false;
}

static void WriteStructPtrVal(void *val, uint8_t *p)
{
    void **pp = (void**)p;
    *pp = val;
}

static uint8_t* DeserializeRec(const uint8_t *data, int dataSize, int dataOff, StructMetadata *def)
{
    uint8_t *res = AllocArray<uint8_t>(def->size);
    FieldMetadata *fieldDef = NULL;
    uint64_t decodedVal;
    int n;
    bool ok;
    for (int i = 0; i < def->nFields; i++) {
        if (dataOff >= dataSize)
            goto Error;
        fieldDef = def->fields + i;
        uint16_t offset = fieldDef->offset;
        uint16_t type = fieldDef->type;
        if (TYPE_STR == type) {
            n = GetVarint64(data + dataOff, dataSize - dataOff, &decodedVal);
            if (0 == n)
                goto Error;
            dataOff += n;
            if (decodedVal > 128*1024) // set a reasonable limit to avoid overflow issues
                goto Error;
            n = (int)decodedVal;
            if (n >= dataSize - dataOff)
                goto Error;
            if (n > 0) {
                char *s = str::DupN((char*)data + dataOff, n);
                dataOff += n;
            }
        } else if (TYPE_STRUCT_PTR == type) {
            n = GetVarint64(data + dataOff, dataSize - dataOff, &decodedVal);
            if (0 == n)
                goto Error;
            dataOff += n;
            if (decodedVal > 512*1024*1024) // avoid overflow issues
                goto Error;
            n = (int)decodedVal;
            uint8_t *d = DeserializeRec(data, dataSize, n, fieldDef->def);
            if (!d)
                goto Error;
            WriteStructPtrVal(d, res + offset);
        } else {
            n = GetVarint64(data + dataOff, dataSize - dataOff, &decodedVal);
            if (0 == n)
                goto Error;
            dataOff += n;
            ok = WriteStructVal(type, decodedVal, res + offset);
            if (!ok)
                goto Error;
        }
    }
    return res;
Error:
    FreeStruct(res, def);
    return NULL;
}

// a serialized format is a linear chunk of memory with pointers
// replaced with offsets from the beginning of the memory (base)
// to deserialize, we malloc() each struct and replace offsets
// with pointers to those newly allocated structs
// TODO: when version of the data doesn't match our version,
// especially in the case of our version being higher (and hence
// having more data), we should decode the default values and
// then over-write them with whatever values we decoded.
// alternatively, we could keep a default value in struct metadata
static uint8_t* Deserialize(const uint8_t *data, int dataSize, const char *version, StructMetadata *def)
{
    if (!data)
        return NULL;
    if (dataSize < sizeof(SerializedHeader))
        return NULL;
    SerializedHeader *hdr = (SerializedHeader*)data;
    if (hdr->magicId != MAGIC_ID)
        return NULL;
    //uint32_t ver = VersionFromStr(version);
    return DeserializeRec(data, dataSize, hdr->topLevelStructOffset, def);
}

// TODO: write me
uint8_t *Serialize(const uint8_t *data, const char *version, StructMetadata *def, int *sizeOut)
{
    *sizeOut = 0;
    return NULL;
}

AdvancedSettings *DeserializeAdvancedSettings(const uint8_t *data, int dataLen, bool *usedDefaultOut)
{
    void *res = NULL;
    res = Deserialize(data, dataLen, AdvancedSettingsVersion, &gAdvancedSettingsMetadata);
    if (res) {
        if (usedDefaultOut)
            *usedDefaultOut = false;
        return (AdvancedSettings*)res;
    }
    res = Deserialize(&gAdvancedSettingsDefault[0], sizeof(gAdvancedSettingsDefault), AdvancedSettingsVersion, &gAdvancedSettingsMetadata);
    CrashAlwaysIf(!res);
    if (usedDefaultOut)
        *usedDefaultOut = true;
    return (AdvancedSettings*)res;
}

uint8_t *SerializeAdvancedSettings(AdvancedSettings *val, int *dataLenOut)
{
    return Serialize((const uint8_t*)val, AdvancedSettingsVersion, &gAdvancedSettingsMetadata, dataLenOut);
}

void FreeAdvancedSettings(AdvancedSettings *val)
{
    FreeStruct((uint8_t*)val, &gAdvancedSettingsMetadata);
}


