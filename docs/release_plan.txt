Things to do before 2.0 release:
* mobi ebook support
* switch to ucrt

Things to do before 2.1 release:
* installer and settings: UI for registering other supported file types
  http://code.google.com/p/sumatrapdf/issues/detail?id=1365
* bug: focus captured by web control when clicking on "Related Topics" button in 
  010Editor.chm from http://code.google.com/p/sumatrapdf/issues/detail?id=1579
  I don't know how to fix this. It seems that the problem really is that a button
  window inside browser control captures the focus. I tried hack it by detecting
  frame window loosing focus (via WM_KILLFOCUS) and doing delayed re-capture of
  focus to frame window, but it doesn't work and it's not the right time to do
  it (it might kill the pop-up menu on the button).

The shortest path to ebook support in sumatra:
1. Make UI responsive during layout process and allow re-layout (when resizing a window)
   which maintains a fixed top of current page when moving forward but re-syncs with
   natural layout when going back. This is what Kindle app does and is important to minimize
   user disorientation in that case. The issue here is that when changing size of the page,
   if we re-layout from the beginning, the part that is currently at the top of the page
   would end up somewher in the middle of another page, which would be disorienting.
   Keeping fixed top of current page requires being able to do layout from arbitrary point
   in the document i.e. top of current page so each page needs enough information to be
   able to do that. At the same time, it's not feasible to re-layout pages before that
   for a different page size, so we effectively need to have 2 layouts: one from the
   beginning and one from current page. As long as we only move forward by a page, we
   use the layout from current page. When going backwards or skipping ahead, we re-sync
   with layout from the beginning and can drop the layout from current page.

2. Support more of the mobi format
2.1 images
2.2 links
2.3 lists (ul, li)

3. Integrate the code into Sumatra. The way I'm thinking about doing it to minimize
   changing existing code:

a) rename WindowInfo to EngineWindowInfo and introduce EbookWindowInfo
b) 
struct WindowInfo {
  enum WindowInfoType { Engine, Ebook };
  WindowInfoType type;
  union {
    EngineWindowInfo engineWindowInfo;
    EbookWindowInfo ebookWindowInfo;
}};

In that scheme, about window (or whatever we'll call it), could be its own type (as opposed
to sharing logic with engine window).

This is introduce the distinction between the thing that is in gWindows array (WindowInfo)
and the thing that current code uses to act upon (EngineWindowInfo). In most cases we
would just fish out EngineWindowInfo from WindowInfo and pass to other functions.

In some cases, like LoadDocument(), we need to take into account the type and do dispatch
based on that. The most difficulat part here is transitioning between types of a window e.g.
when opening an ebook in what is currently engine window (and vice versa).

The simplest way is to create a completely new window with desired type on top of existing
window and close the old one. Another possibility is to write code that transitions from one
type to another e.g. transitioning from engine window to ebook window would involve destroying
all its hwnd windows etc.
