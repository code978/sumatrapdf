This is an exploration of ideas for how make threaded code easy and
safe. The code here is just for sketching the api.

High-level goals:
- easy to use API
- encourages a style that is safe (as safe as threading can be) i.e.
  tries to encourage clear ownership of data so that only one thread
  owns the data. Most of the bugs are caused by incorrectly modyfing
  shared memory
- it's mostly about doing things on UI thread with the results
  of background thread work
  
Non-goals:
- make it efficient for a large number of async operations (i.e. threads)

------------------------------------------------------------------------
Idea no 1: try to model Go's channels and gorutines as much as
possible in C++. 

In Go goroutines (i.e. threads) communicate by sending (typed) messages
on channels. That's easy enough to model:

template <typename T>
class Channel {
    Channel(int bufferSize = 0); // 0 - unbuffered
    void Send(T *msg);
    T *Receive();
};

A send on a channel is blocking if the channel is unbuffered or 
non-blocking if a channel is buffered.

We could extend Go's notion of channels with two capabilities:
- a way to notify the thread that we want it to stop processing
  further messages. T could be used to do that (e.g. by adding a field
  bool pleaseStop) and sending a message with pleaseStop = true, but
  it could would be nice to have it built-in
- a way for the sender (most likely the background thread) to notify the 
  receiver (most likely the UI thread), that it had finished. We could
  also introduce a notion of successful/failed termination (e.g.
  a background thread loading a mobi file would be able to notify
  about an error

That gives us:

template <typename T>
class Channel {
    Channel(int bufferSize = 0); // 0 - unbuffered

    // send a message on a channel. Blocks if unbuffered or if
    // buffer if full
    void Send(T *msg);

    // get a new message from the channel. Blocks if channel is empty.
    // It owns the message so should delete it when done.
    // We could also add optional timeout
    T *Receive();

    // ask the receiver to stop. After than, WasCancelled() returns
    // true, so that it can be checked at any point by receiver
    // and Receive() returns NULL if Cancel() (or FinishedWork()
    // was called when the receiver was blocked waiting for new messages
    void Cancel();
    bool WasCanceled();

    // Tell the receiver that the sender finished producing values
    // After this DidFinishWork() returns true and also Receive()
    // returns NULL if the receiver was waiting
    void MarkFinishedWork();
    bool DidFinishWork();
};

Cancel() and MarkFinishedWork() do technically the same thing but I
think it's good to have clear semantics for those cases.

When it comes to background threads, implementing Channel is easy (each
channel has a HANDLE that is an event that is pulsed on new messages
and Receive() uses WaitForSingleObject()). 

UI thread, however, is different, in that it cannot block in Receive()
because there might be more than one pieces of ui code that spawns
threads and wants to be notified on new messages, so we need to come up
with an API that allows for a piece of code to be called on a ui thread
when a message comes in on a channel.

template <typename T>
class UIChannel : Channel {
    UIChannel();
    void SetCallback(Callback<void(T) onMessage);
};

Then if we want Foo::OnMessageT(UIChannel<T> *chan, T *msg) to be called,
we would do:

void Foo::OnMessageT(UIChannel<T> *chan, T *msg) {
   // process the message
}

void Foo::StartAsyncWork()
{
    Callback<void(UIChannel<T>*, T*)> cb = Bind(&Foo::OnMessageT, this);
    UIChannel<T> ch* = new UICHannel<T>();
    ch->SetCallback(cb);
}

UIChannels would register their HANDLEs globally. We would wait for
them all using MsgWaitForMultipleObjects() in our message loop.
We would figure out which UIChannel() has been notified about a new
message with T *msg = chan->Receive() and dispatch a callback with 
cb.Run(ch, msg).

After we create a channel, we need to start a thread:

void ThreadFunc(Channel<T> *chanIn, Channel<TResult> *chanOut) {
  for (;;) {
    T *msg = chanIn->Receive();
    ...
    TResult *res = new TResult();
    chanOut->Send(res);
  }
  chanOut->MarkFinishedWork();
}

Channel<T> *chanIn = new Channel<T>();
Channel<TResult> *chanOut = new Channel<TResult>();
StartThread(Bind(&ThreadFunc, chanIn, chanOut));

Problems: I'm not sure if it's possible to do the UI thread dispatcher
with templated UIChannels as they're not of the same type.

We could do Send() and Receive() as virtual functions using void *, but
that would loose strong typing of messages. Maybe we can have a base
Channel with virtual void *Receive(), virtual void Send(void *) and
a type-safe, templated wrapper deriving from them?
------------------------------------------------------------------------
