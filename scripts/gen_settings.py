#!/usr/bin/env python

import os, struct, types
import util, gen_settings_2_3
from gen_settings_types import gen_h_struct_defs

"""
Script that generates C code for compact storage of settings.

In C settings are represented as a top-level struct (which can then refer to
other structs). The first field of top-level struct must be a u32 version
field. A version supports up to 4 components, each component in range <0,255>.
For example version "2.1.3" is encoded as: u32 version = (2 << 24) | (1 << 16) | (3 << 8) | 0.
This way versions can be compared with ">" in C code with the right semantics
(e.g. 2.2.1 > 2.1).

We support generating multiple top-level structs (which can be used for multiple
different purposes).

In order to support forward and backward compatibility, struct for a given
version must be a strict superset of struct for a previous version. We can
only add, we can't remove fields or change their types (we can change the names
of fields).

By convention, settings for each version of Sumatra are in gen_settings_$ver.py
file. For example, settings for version 2.3 are in gen_settings_2_3.py.

That way we can inherit settings for version N from settings for version N-1.

We rely on an exact layout of data in the struct, so:
 - we don't use C types whose size is not fixed (e.g. int)
 - we use a fixed struct packing (that's TODO)
 - our pointers are always 8 bytes, to support both 64-bit and 32-bit archs
   with the same definition

TODO:
 - calculate the pointer offset in structs
 - add a notion of value to allow multiple values in the settings chain
   that have the same struct type
 - add a notion of Struct inheritance to make it easy to support forward/backward
   compatibility
 - const char *serialize_struct(char *data, StructDef *def);
 - introduce a concept of array i.e. a count + type of values + pointer to 
   values (requires adding a notion of value first)
 - add size as the first field of each struct, for forward-compatibilty
 - maybe: add a signature at the beginning of each struct to detect
   corruption of the values (crash if that happens)
 - maybe: add a compare function. That way we could optimize saving
   (only save if the values have changed)
 - maybe: change "bool" to be int32_t, to avoid potential problems
   with other compilers. I thought that bool is int32_t but it seems
   in Visual C it's int16_t
"""

h_tmpl = """
// DON'T EDIT MANUALLY !!!!
// auto-generated by scripts/gen_settings.py !!!!

#ifndef Settings_h
#define Settings_h

template <typename T>
union Ptr {
    T *       ptr;
    char      b[8];
};

STATIC_ASSERT(8 == sizeof(Ptr<int>), ptr_is_8_bytes);

%(h_struct_defs)s
#endif
"""

cpp_tmpl = """
// DON'T EDIT MANUALLY !!!!
// auto-generated by scripts/gen_settings.py !!!!

#include "BaseUtil.h"
#include "Settings.h"

struct StructPointerInfo;

#define POINTER_SIZE 8

typedef struct {
    int                  size;
    int                  pointersCount;
    StructPointerInfo *  pointersInfo;
} StructDef;

// information about a single field
struct StructPointerInfo {
    // from the beginning of the struct
    int offset;
    // what kind of structure it points to, needed
    // for recursive application of the algorithm
    // NULL if that structure doesn't need fixup
    // (has no pointers)
    StructDef *def;
};

%(cpp_body)s

%(global_data)s

// a serialized format is a linear chunk of memory with pointers
// replaced with offsets from the beginning of the memory (base)
// to deserialize, we malloc() each struct and replace offsets
// with pointers to those newly allocated structs
char* deserialize_struct(const char *data, StructDef *def, const char *base, const int totalSize)
{
    int size = def->size;
    char *dataCopy = AllocArray<char>(size);
    // TODO: when we add size to each struct, we only copy up to that size
    memcpy(dataCopy, data, size);

    // this struct doesn't have pointer members to fix up
    if (!def)
        return dataCopy;

    for (int i=0; i < def->pointersCount; i++) {
        int memberOffset = def->pointersInfo[i].offset;
        StructDef *memberDef = def->pointersInfo[i].def;
        Ptr<char> *ptrToMemberPtr = (Ptr<char>*)(dataCopy + memberOffset);
        int memberDataOffset = (int)ptrToMemberPtr->ptr;
        ZeroMemory(ptrToMemberPtr, 8);
        if (memberDataOffset != 0) {
            CrashIf(memberDataOffset + memberDef->size > totalSize);
            char *memberDataNew = deserialize_struct(base + memberDataOffset, memberDef, base, totalSize);
            ptrToMemberPtr->ptr = memberDataNew;
        }
    }

    return dataCopy;
}

// the assumption here is that the data was either build by deserialize_struct
// or was set by application code in a way that observes our rule: each
// object was separately allocated with malloc()
void free_struct(char *data, StructDef *def)
{
    // recursively free all structs reachable from this struct
    for (int i=0; i < def->pointersCount; i++) {
        int memberOffset = def->pointersInfo[i].offset;
        Ptr<char> *ptrToPtr = (Ptr<char>*)(data + memberOffset);
        char *memberData = ptrToPtr->ptr;
        StructDef *memberDef = def->pointersInfo[i].def;
        if (memberData && memberDef)
            free_struct(memberData, memberDef);
        free(memberData);
    }
    free(data);
}

// TODO: write me
const char *serialize_struct(char *data, StructDef *def, uint32_t *sizeOut)
{
    *sizeOut = 0;
    return NULL;
}

"""

# must be called before calling gen_* functions
def build_structs(stru):
    # first field of the top-level struct must be a version
    assert "version" == stru.fields[0].name and "u32" == stru.fields[0].typ
    structs_remaining = [stru]
    structs_done = []
    while len(structs_remaining) > 0:
        stru = structs_remaining.pop(0)
        structs_done.append(stru)
        for field in stru.fields:
            if field.is_struct():
                structs_remaining.append(field.typ)

    offset = 0
    for stru in reversed(structs_done):
        stru.base_offset = offset
        offset += stru.size
    return structs_done

"""
STATIC_ASSERT(offsetof($struct_name, $field_name) == $offset, $field_name_is_$offset_bytes_in_$struct_name);
StructPointerInfo gFooPointers[] = {
    { $offset, &gFooStructDef },
};
"""
def gen_struct_pointer_infos_one(stru):
    name = stru.name
    lines = []
    for field in stru.get_struct_fields():
        struct_name = name
        field_name = field.name
        offset = field.offset
        lines += ["STATIC_ASSERT(offsetof(%(struct_name)s, %(field_name)s) == %(offset)d, %(field_name)s_is_%(offset)d_bytes_in_%(struct_name)s);" % locals()]

    lines += ["StructPointerInfo g%(name)sPointers[] = {" % locals()]
    for field in stru.get_struct_fields():
        offset = field.offset
        name = field.typ.name
        lines += ["    { %(offset)d, &g%(name)sStructDef }," % locals()]
    lines += ["};\n"]
    return lines

def gen_struct_pointer_infos(fields):
    lines = []
    for field in  fields:
        lines += gen_struct_pointer_infos_one(field.typ)
    return lines

"""
STATIC_ASSERT(sizeof(gForwardSearchSettingsStructDef) == 16, gForwardSearchSettingsStructDef_is_16_bytes);
StructDef gFooStructDef = { $size, $pointersCount, &g${Foo}Pointers[0] };"""
def gen_c_struct_metadata(stru):
    name = stru.name
    size = stru.size
    fields = stru.get_struct_fields()
    pointer_infos_count = len(fields)
    pointer_infos = "NULL"
    lines = []
    if len(fields) > 0:
        pointer_infos = "&g%sPointers[0]" % name
        lines += gen_struct_pointer_infos_one(stru)
    lines += ["STATIC_ASSERT(sizeof(%(name)s) == %(size)d, %(name)s_is_%(size)d_bytes);" % locals()]
    lines += ["StructDef g%(name)sStructDef = { %(size)d, %(pointer_infos_count)d, %(pointer_infos)s };\n" % locals()]
    return "\n".join(lines)

def data_to_hex(data):
    els = ["0x%02x" % ord(c) for c in data]
    return ", ".join(els)

def is_of_num_type(val):
    tp = type(val)
    return tp == types.IntType or tp == types.LongType

"""
  // $StructName
  0x00, 0x01, // $type $name = $val
  ...
"""
def get_cpp_data_one(stru):
    name = stru.name
    lines = ["", "  // %s" % name]
    for field in stru.fields:
        val = field.def_val
        if val == None:
            val = 0
        fmt = field.pack_format()
        data = struct.pack(fmt, val)
        data_hex = data_to_hex(data)
        var_type = field.c_type()
        var_name = field.name
        if is_of_num_type(val):
            val_str = hex(val)
        else:
            val_str = str(val)
        s = "  %(data_hex)s, // %(var_type)s %(var_name)s = %(val_str)s" % locals()
        lines += [s]
    return lines

"""
static uint8_t g$(StructName)Default[] = {
   ... data    
};
"""
def gen_cpp_data(structs):
    name = structs[0].name
    lines = ["static uint8_t g%sDefault[] = {" % name]
    for stru in structs:
        lines += get_cpp_data_one(stru)
    lines += ["};"]
    return "\n".join(lines)

def gen_cpp_for_structs(structs):
    return "\n".join([gen_c_struct_metadata(stru) for stru in reversed(structs)])

def src_dir():
    d = os.path.dirname(__file__)
    p = os.path.join(d, "..", "src")
    return util.verify_path_exists(p)

def write_to_file(file_path, s): file(file_path, "w").write(s)

def main():
    dst_dir = src_dir()

    h_struct_defs = gen_h_struct_defs()
    h_txt = h_tmpl % locals()
    write_to_file(os.path.join(dst_dir, "Settings.h"), h_txt)

    #structs = build_structs(gen_settings_2_3.advancedSettings)

    #cpp_body = gen_cpp_for_structs(structs)
    #global_data = gen_cpp_data(structs)
    #cpp_txt = cpp_tmpl % locals()
    #write_to_file(os.path.join(dst_dir, "Settings.cpp"), cpp_txt)

if __name__ == "__main__":
    main()
