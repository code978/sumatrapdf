#!/usr/bin/env python

import os, util
from gen_settings_types2 import Bool, U16, I32, U64, Float, Color
from gen_settings_types2 import String, WString, Struct
from util import gob_varint_encode, gob_uvarint_encode

class PaddingSettings(Struct):
    fields =[
        ("top", U16(2)),
        ("bottom", U16(2)),
        ("left", U16(4)),
        ("right", U16(4)),
        ("spaceX", U16(4)),
        ("spaceY", U16(4))
    ]

class ForwardSearch(Struct):
    fields = [
        ("highlightOffset", I32(0)),
        ("highlightWidth", I32(15)),
        ("highlightPermanent", I32(0)),
        ("highlightColor", Color(0x6581FF)),
        ("enableTeXEnhancements", Bool(False)),
]

class RectInt(Struct):
    fields = [
        ("x", I32(0)),
        ("y", I32(0)),
        ("dx", I32(0)),
        ("dy", I32(0)),
    ]

class BasicSettings(Struct):
    fields = [
        ("globalPrefsOnly", Bool(False)),
        ("currLanguage", String(None)), # auto-detect
        ("toolbarVisible", Bool(True)),
        ("pdfAssociateDontAsk", Bool(False)),
        ("pdfAssociateDoIt", Bool(False)),
        ("checkForUpdates", Bool(True)),
        ("rememberMRUFiles", Bool(True)),
        # TODO: useSystemColorScheme obsolete by textColor/pageColor ?
        ("useSystemColorScheme", Bool(False)),
        ("inverseSearchCmdLine", String(None)),
        ("versionToSkip", String(None)),
        ("lastUpdateTime", String(None)),
        ("defaultDisplayMode", U16(0)),  # DM_AUTOMATIC
        # -1 == Fit Page
        ("defaultZoom", Float(-1)),
        ("windowState", I32(1)), # WIN_STATE_NORMAL
        ("windowPos", RectInt()),
        ("tocVisible", Bool(True)),
        ("favVisible", Bool(False)),
        ("sidebarDx", I32(0)),
        ("tocDy", I32(0)),
        ("showStartPage", Bool(True)),
        ("openCountWeek", I32(0)),
        ("lastPrefUpdate", U64(0)),
    ]

class AdvancedSettings(Struct):
    fields = [
        ("traditionalEbookUI", Bool(True)),
        ("escToExit", Bool(False)),
        # TODO: different for different document types? For example, ebook
        # really needs one just for itself
        ("textColor", Color(0x0)),      # black
        ("pageColor", Color(0xffffff)), # white
        ("mainWindowBackground", Color(0xFFF200)),
        ("pagePadding", PaddingSettings()),
        ("forwardSearch", ForwardSearch()),

        # TODO: just for testing
        ("s", String("Hello")),
        ("defaultZoom", Float(-1)),
        ("ws", WString("A wide string")),
    ]

# TODO: merge basic/advanced into one?
class Settings(Struct):
    fields = [
        ("basic", BasicSettings()),
        ("advanced", AdvancedSettings()),
        # TODO: just for testing
        #Array("intArray", I32, [I32("", 1), I32("", 3)]),
    ]

settings = Settings()
version = "2.3"

g_magic_id = 0x53657454  # 'SetT' as 'Settings''
g_magic_id_str = "SetT"

def script_dir(): return os.path.dirname(__file__)
def src_dir():
    p = os.path.join(script_dir(), "..", "src")
    return util.verify_path_exists(p)

def to_win_newlines(s):
    s = s.replace("\r\n", "\n")
    s = s.replace("\n", "\r\n")
    return s

def write_to_file(file_path, s): file(file_path, "w").write(to_win_newlines(s))

h_tmpl   ="""// DON'T EDIT MANUALLY !!!!
// auto-generated by scripts/gen_settings.py !!!!

#ifndef SettingsSumatra_h
#define SettingsSumatra_h

%(h_struct_defs)s
#endif
"""

cpp_tmpl = """// DON'T EDIT MANUALLY !!!!
// auto-generated by scripts/gen_settings.py !!!!

#include "BaseUtil.h"
#include "Settings.h"
#include "SettingsSumatra.h"

using namespace settings;

%(structs_metadata)s
%(values_global_data)s
%(top_level_funcs)s
"""

def ver_from_string(ver_str):
    parts = ver_str.split(".")
    assert len(parts) <= 4
    parts = [int(p) for p in parts]
    for n in parts:
        assert n > 0 and n < 255
    n = 4 - len(parts)
    if n > 0:
        parts = parts + [0]*n
    return parts[0] << 24 | parts[1] << 16 | parts[2] << 8 | parts[3]

# val is a top-level StructVal with primitive types and
# references to other struct types (forming a tree of values).
# we flatten the values into a list, in the reverse order of
# tree traversal
def flatten_struct(stru):
    assert isinstance(stru, Struct)
    vals = []
    left = [stru]
    while len(left) > 0:
        stru = left.pop(0)
        assert isinstance(stru, Struct)
        vals += [stru]
        for field in stru.values:
            if field.is_struct():
                if field.val != None:
                    assert isinstance(field.val, Struct)
                    left += [field.val]
    vals.reverse()
    return vals

# serialize values in vals and calculate offset of each
# val in encoded data.
# values are serialized in reverse order because
# it would be very complicated to serialize forward
# offsets in variable-length encoding
def serialize_top_level_struct(top_level_struct):
    vals = flatten_struct(top_level_struct)

    # the first 12 bytes are:
    #  - 4 bytes magic constant (for robustness)
    #  - 4 bytes for version
    #  - 4 bytes offset pointing to a top-level structure
    #      within the data
    offset = 12
    for stru in vals:
        stru.offset = offset
        for field in stru.values:
            data = field.serialized()
            offset += len(data)
        fields_count = len(stru.values)
        offset = offset + 4 + len(gob_uvarint_encode(fields_count))
    return vals

def main():
    dst_dir = src_dir()

    val = settings
    version_str = version
    vals = serialize_top_level_struct(val)
    print(vals)

if __name__ == "__main__":
    main()
