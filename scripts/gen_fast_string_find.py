#!/usr/bin/python
"""
This script generates the fastest possible C code for the following
function: given a string, see if it belongs to a known set of strings.
If it does, return an enum corresponding to that string.
It can be thought of as internalizing a string.

TODO: this is not actually the fastest possible implementation.
Assuming our set of known strings is "a", "abba2", "bo", the fastest
possible implementation would be along the lines:

int FindTag(char *s, size_t len)
{
    char c = *s++; --len;
    if (c == 'a') {
        if (0 == len) return Tag_A;
        if ((len == 4) && memeq(s, "bba2", 4)) return Tag_Abba2;
    } else if (c == 'b') {
        if ((len == 1) && (*s == 'o')) return Tag_Bo;
    }
    return Tag_NotFound;
}

or:

uint32_t GetUpToFour(char*& s, size_t& len)
{
    CrashIf(0 == len);
    size_t n = 0;
    uint32_t v = *s++; len--;
    while ((n < 3) && (len > 0)) {
        v = v << 8;
        v = v | *s++;
        len--; n++;
    }
    return v;
}

#define V_A 'a'
#define V_BO  (('b' << 8) | 'o'))
#define V_ABBA ...
#define V_2 ...

int FindTag(char *s, size_t len)
{
    uint32_t v = GetUpToFour(s, len);
    if (v == V_A) return Tag_A;
    if (v == V_BO) return Tag_B;
    if (v == V_ABBA) {
        v = GetUpToFour(s, len);
        if (v == V_2) return Tag_Abba2;
     }
     return Tag_NotFound;
}

This code generator isn't smart enough to generate such code yet.
"""

import string

# first letter upper case, rest lower case
def capitalize(s):
    s = s.lower()
    return s[0].upper() + s[1:]

# given e.g. "br", returns "Tag_Br"
def enum_name_from_tag_name(tag):
    parts = tag.split(":")
    parts = [capitalize(p) for p in parts]
    parts = ["Tag"] + parts
    return string.join(parts, "_")

# This list has been generated by instrumenting MobiHtmlParse.cpp
# to dump all tags we see in a mobi file
g_tags_str = "a b blockquote body br div font guide h2 head html i img li mbp:pagebreak ol p reference span sup table td tr u ul"

find_simple_c = """
// enum names match the order of tags in an array
enum TagEnum {
    TagNotFound = -1,
    %s
};

char *gTags = "%s";

TagEnum FindTag(char *tag, size_t len)
{
    char *curr = gTags;
    char *end = tag + len;
    char firstTagChar = *tag;
    int n = 0;
    for (;;) {
        // we're at the start of the next tag
        char c = *curr;
        if ((0 == c) || (c > firstTagChar)) {
            // gTags are sorted alphabetically, so we
            // can quit if current tag is > tag
            return TagNotFound;
        }
        char *s = tag;
        while (*curr && (s < end)) {
            if (*s++ != *curr++)
                goto NextTag;
        }
        if ((s == end) && (0 == *curr))
            return (TagEnum)n;
NextTag:
        while (*curr) {
            ++curr;
        }
        ++curr;
        ++n;
    }
    return TagNotFound;
}
"""

def main():
    tags = [t.lower() for t in g_tags_str.split(" ")]
    tags.sort()
    # el[0] is tag, el[1] is 0-based position of the tag
    tag_enums = [(enum_name_from_tag_name(el[0]), el[1]) for el in zip(tags, range(len(tags)))]
    tags_strings = ["%s = %d" % t for t in tag_enums]
    tags_enums_str = string.join(tags_strings, ",\n    ")
    gTags_str = string.join(tags, "\\0") + "\\0"
    print(find_simple_c % (tags_enums_str, gTags_str))
    #print(tags_str)

if __name__ == "__main__":
    main()
