diff -rPu5 openjpeg.orig\j2k.c openjpeg\j2k.c
--- openjpeg.orig\j2k.c	Sat May 18 20:52:42 2013
+++ openjpeg\j2k.c	Sun May 19 04:37:13 2013
@@ -1930,10 +1930,16 @@
         if (l_image->numcomps != l_nb_comp) {
                 opj_event_msg(p_manager, EVT_ERROR, "Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\n", l_image->numcomps, l_nb_comp);
                 return OPJ_FALSE;
         }
 
+        /* cf. http://code.google.com/p/openjpeg/issues/detail?id=169 */
+        if (!(l_cp->tdx * l_cp->tdy)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n", l_cp->tdx, l_cp->tdy);
+                return OPJ_FALSE;
+        }
+
 #ifdef USE_JPWL
         if (l_cp->correct) {
                 /* if JPWL is on, we check whether TX errors have damaged
                   too much the SIZ parameters */
                 if (!(l_image->x1 * l_image->y1)) {
@@ -4434,10 +4440,18 @@
                         }
                 }
         };
 #endif /* USE_JPWL */
 
+        /* cf. http://code.google.com/p/openjpeg/issues/detail?id=166 */
+        if (l_comp_room >= l_nb_comp) {
+                opj_event_msg(p_manager, EVT_ERROR,
+                        "JPWL: bad component number in RGN (%d when there are only %d)\n",
+                        l_comp_room, l_nb_comp);
+                return OPJ_FALSE;
+        }
+
         opj_read_bytes(p_header_data,(OPJ_UINT32 *) (&(l_tcp->tccps[l_comp_no].roishift)),1);   /* SPrgn */
         ++p_header_data;
 
         return OPJ_TRUE;
 
@@ -5910,11 +5924,12 @@
                 tcp->POC = 0;
 
                 if (parameters->numpocs) {
                         /* initialisation of POC */
                         tcp->POC = 1;
-                        for (i = 0; i < parameters->numpocs; i++) {
+                        /* cf. http://code.google.com/p/openjpeg/issues/detail?id=165 */
+                        for (i = 0; i < opj_uint_min(parameters->numpocs, 32); i++) {
                                 if (tileno + 1 == parameters->POC[i].tile )  {
                                         opj_poc_t *tcp_poc = &tcp->pocs[numpocs_tile];
 
                                         tcp_poc->resno0         = parameters->POC[numpocs_tile].resno0;
                                         tcp_poc->compno0        = parameters->POC[numpocs_tile].compno0;
diff -rPu5 openjpeg.orig\opj_config.h openjpeg\opj_config.h
--- openjpeg.orig\opj_config.h	Thu Jan 01 01:00:00 1970
+++ openjpeg\opj_config.h	Sun May 19 03:54:43 2013
@@ -0,0 +1 @@
+// #define OPJ_HAVE_STDINT_H
diff -rPu5 openjpeg.orig\opj_config_private.h openjpeg\opj_config_private.h
--- openjpeg.orig\opj_config_private.h	Thu Jan 01 01:00:00 1970
+++ openjpeg\opj_config_private.h	Sun May 19 03:54:40 2013
@@ -0,0 +1,9 @@
+#define OPJ_PACKAGE_VERSION "2.0.0"
+
+// #define OPJ_HAVE_INTTYPES_H
+// #define OPJ_HAVE_FSEEKO
+
+#define OPJ_STATIC
+#define OPJ_EXPORTS
+
+#define USE_JPIP
